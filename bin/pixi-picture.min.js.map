{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/PictureRenderer.js","pixi-picture.min.js","src/PictureShader.js","src/PictureSprite.js","src/index"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","PictureRenderer","renderer","PIXI","ObjectRenderer","this","PictureShader","glCore","prototype","Object","create","constructor","onContextChange","gl","quad","Quad","normalShader","initVao","_tempClamp","Float32Array","_tempColor","start","flush","render","sprite","texture","valid","_renderNormal","shader","bindShader","state","setBlendMode","blendMode","uvs","_uvs","vertices","vertexData","x0","y0","x1","y1","x2","y2","x3","y3","upload","frame","base","baseTexture","clamp","x","width","realWidth","y","height","uniforms","uTextureClamp","color","utils","hex2rgb","tint","alpha","worldAlpha","uColor","bindTexture","draw","WebGLRenderer","registerPlugin","./PictureShader","2","Shader","bind","3","PictureSprite","Sprite","_renderWebGL","transform","updated","textureDirty","calculateVertices","setObjectRenderer","plugins","picture","4","myPlugin","assign","extras","./PictureRenderer","./PictureSprite"],"mappings":"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","file":"pixi-picture.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var PictureShader = require('./PictureShader'),\r\n    glCore = PIXI.glCore;\r\n\r\n/**\r\n * Renderer that clamps the texture so neighbour frames wont bleed on it\r\n * immitates context2d drawImage behaviour\r\n *\r\n * @class\r\n * @memberof PIXI.extras\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this plugin works for\r\n */\r\nfunction PictureRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n}\r\n\r\nPictureRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nPictureRenderer.prototype.constructor = PictureRenderer;\r\n\r\nPictureRenderer.prototype.onContextChange = function() {\r\n    var gl = this.renderer.gl;\r\n    this.quad = new PIXI.Quad(gl);\r\n    this.normalShader = new PictureShader(gl);\r\n    this.quad.initVao(this.normalShader);\r\n    this._tempClamp = new Float32Array(4);\r\n    this._tempColor = new Float32Array(4);\r\n};\r\n\r\nPictureRenderer.prototype.start = function() {\r\n    //noop\r\n};\r\n\r\nPictureRenderer.prototype.flush = function() {\r\n    //noop\r\n};\r\n\r\n/**\r\n * Renders the picture object.\r\n *\r\n * @param sprite {PIXI.tilemap.PictureSprite} the picture to render\r\n */\r\nPictureRenderer.prototype.render = function(sprite) {\r\n    if (!sprite.texture.valid) {\r\n        return;\r\n    }\r\n\t//you can add different render modes here\r\n\t//multiple shaders and stuff\r\n    this._renderNormal(sprite, this.normalShader);\r\n};\r\n\r\nPictureRenderer.prototype._renderNormal = function(sprite, shader) {\r\n    var renderer = this.renderer;\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(sprite.blendMode);\r\n    var quad = this.quad;\r\n    var uvs = sprite.texture._uvs;\r\n\r\n\t//sprite already has calculated the vertices. lets transfer them to quad\r\n    var vertices = quad.vertices;\r\n    for (var i=0;i<8;i++) {\r\n        quad.vertices[i] = sprite.vertexData[i];\r\n    }\r\n\r\n    //SpriteRenderer works differently, with uint32 UVS\r\n\t//but for our demo float uvs are just fine\r\n    quad.uvs[0] = uvs.x0;\r\n    quad.uvs[1] = uvs.y0;\r\n    quad.uvs[2] = uvs.x1;\r\n    quad.uvs[3] = uvs.y1;\r\n    quad.uvs[4] = uvs.x2;\r\n    quad.uvs[5] = uvs.y2;\r\n    quad.uvs[6] = uvs.x3;\r\n    quad.uvs[7] = uvs.y3;\r\n\r\n    //TODO: add baricentric coords here\r\n    quad.upload();\r\n\r\n    var frame = sprite.texture.frame;\r\n    var base = sprite.texture.baseTexture;\r\n    var clamp = this._tempClamp;\r\n\t//clamping 0.5 pixel from each side to reduce border artifact\r\n\t//this is our plugin main purpose\r\n    clamp[0] = frame.x / base.width + 0.5 / base.realWidth;\r\n    clamp[1] = frame.y / base.height + 0.5 / base.realWidth;\r\n    clamp[2] = (frame.x + frame.width) / base.width - 0.5 / base.realWidth;\r\n    clamp[3] = (frame.y + frame.height) / base.height - 0.5 / base.realWidth;\r\n\t//take a notice that size in pixels is realWidth,realHeight\r\n\t//width and height are divided by resolution\r\n    shader.uniforms.uTextureClamp = clamp;\r\n\r\n    var color = this._tempColor;\r\n    PIXI.utils.hex2rgb(sprite.tint, color);\r\n    var alpha = sprite.worldAlpha;\r\n\t//premultiplied alpha tint\r\n\t//of course we could do that in shader too\r\n    color[0] *= alpha;\r\n    color[1] *= alpha;\r\n    color[2] *= alpha;\r\n    color[3] = alpha;\r\n    shader.uniforms.uColor = color;\r\n\r\n\t//bind texture to unit 0, our default sampler unit\r\n    renderer.bindTexture(base, 0);\r\n    quad.draw();\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\r\n\r\nmodule.exports = PictureRenderer;\r\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar PictureShader = require('./PictureShader'),\r\n    glCore = PIXI.glCore;\r\n\r\n/**\r\n * Renderer that clamps the texture so neighbour frames wont bleed on it\r\n * immitates context2d drawImage behaviour\r\n *\r\n * @class\r\n * @memberof PIXI.extras\r\n * @extends PIXI.ObjectRenderer\r\n * @param renderer {PIXI.WebGLRenderer} The renderer this plugin works for\r\n */\r\nfunction PictureRenderer(renderer) {\r\n    PIXI.ObjectRenderer.call(this, renderer);\r\n}\r\n\r\nPictureRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\r\nPictureRenderer.prototype.constructor = PictureRenderer;\r\n\r\nPictureRenderer.prototype.onContextChange = function() {\r\n    var gl = this.renderer.gl;\r\n    this.quad = new PIXI.Quad(gl);\r\n    this.normalShader = new PictureShader(gl);\r\n    this.quad.initVao(this.normalShader);\r\n    this._tempClamp = new Float32Array(4);\r\n    this._tempColor = new Float32Array(4);\r\n};\r\n\r\nPictureRenderer.prototype.start = function() {\r\n    //noop\r\n};\r\n\r\nPictureRenderer.prototype.flush = function() {\r\n    //noop\r\n};\r\n\r\n/**\r\n * Renders the picture object.\r\n *\r\n * @param sprite {PIXI.tilemap.PictureSprite} the picture to render\r\n */\r\nPictureRenderer.prototype.render = function(sprite) {\r\n    if (!sprite.texture.valid) {\r\n        return;\r\n    }\r\n\t//you can add different render modes here\r\n\t//multiple shaders and stuff\r\n    this._renderNormal(sprite, this.normalShader);\r\n};\r\n\r\nPictureRenderer.prototype._renderNormal = function(sprite, shader) {\r\n    var renderer = this.renderer;\r\n    renderer.bindShader(shader);\r\n    renderer.state.setBlendMode(sprite.blendMode);\r\n    var quad = this.quad;\r\n    var uvs = sprite.texture._uvs;\r\n\r\n\t//sprite already has calculated the vertices. lets transfer them to quad\r\n    var vertices = quad.vertices;\r\n    for (var i=0;i<8;i++) {\r\n        quad.vertices[i] = sprite.vertexData[i];\r\n    }\r\n\r\n    //SpriteRenderer works differently, with uint32 UVS\r\n\t//but for our demo float uvs are just fine\r\n    quad.uvs[0] = uvs.x0;\r\n    quad.uvs[1] = uvs.y0;\r\n    quad.uvs[2] = uvs.x1;\r\n    quad.uvs[3] = uvs.y1;\r\n    quad.uvs[4] = uvs.x2;\r\n    quad.uvs[5] = uvs.y2;\r\n    quad.uvs[6] = uvs.x3;\r\n    quad.uvs[7] = uvs.y3;\r\n\r\n    //TODO: add baricentric coords here\r\n    quad.upload();\r\n\r\n    var frame = sprite.texture.frame;\r\n    var base = sprite.texture.baseTexture;\r\n    var clamp = this._tempClamp;\r\n\t//clamping 0.5 pixel from each side to reduce border artifact\r\n\t//this is our plugin main purpose\r\n    clamp[0] = frame.x / base.width + 0.5 / base.realWidth;\r\n    clamp[1] = frame.y / base.height + 0.5 / base.realWidth;\r\n    clamp[2] = (frame.x + frame.width) / base.width - 0.5 / base.realWidth;\r\n    clamp[3] = (frame.y + frame.height) / base.height - 0.5 / base.realWidth;\r\n\t//take a notice that size in pixels is realWidth,realHeight\r\n\t//width and height are divided by resolution\r\n    shader.uniforms.uTextureClamp = clamp;\r\n\r\n    var color = this._tempColor;\r\n    PIXI.utils.hex2rgb(sprite.tint, color);\r\n    var alpha = sprite.worldAlpha;\r\n\t//premultiplied alpha tint\r\n\t//of course we could do that in shader too\r\n    color[0] *= alpha;\r\n    color[1] *= alpha;\r\n    color[2] *= alpha;\r\n    color[3] = alpha;\r\n    shader.uniforms.uColor = color;\r\n\r\n\t//bind texture to unit 0, our default sampler unit\r\n    renderer.bindTexture(base, 0);\r\n    quad.draw();\r\n};\r\n\r\nPIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\r\n\r\nmodule.exports = PictureRenderer;\r\n\n},{\"./PictureShader\":2}],2:[function(require,module,exports){\n\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction PictureShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n   \\tvec4 sample = texture2D(uSampler, textureCoord);\\n\\n   \\tgl_FragColor = sample * uColor;\\n\\n}\\n\\n\"\r\n    );\r\n\t//do some stuff, like default values for shader\r\n\t//dont forget to bind it if you really are changing the uniforms\r\n\tthis.bind();\r\n\t//default tint\r\n\t//Its an example, actually PictureRenderer takes care of this stuff\r\n\tthis.uniforms.uColor = new Float32Array(1,1,1,1);\r\n}\r\n\r\nPictureShader.prototype = Object.create(PIXI.Shader.prototype);\r\nPictureShader.prototype.constructor = PictureShader;\r\nmodule.exports = PictureShader;\r\n\n},{}],3:[function(require,module,exports){\n/**\r\n * A Sprite with reduced border artifacts\r\n *\r\n * @class\r\n * @extends PIXI.Sprite\r\n * @memberof PIXI.tilemap\r\n * @param texture {PIXI.Texture} the texture for this sprite\r\n */\r\nfunction PictureSprite(texture)\r\n{\r\n    PIXI.Sprite.call(this, texture);\r\n}\r\n\r\nPictureSprite.prototype = Object.create(PIXI.Sprite.prototype);\r\nPictureSprite.prototype.constructor = PictureSprite;\r\nmodule.exports = PictureSprite;\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {PIXI.WebGLRenderer}\r\n * @private\r\n */\r\nPictureSprite.prototype._renderWebGL = function (renderer)\r\n{\r\n\t//copy of PIXI.Sprite v4 behaviour\r\n    if(this.transform.updated || this.textureDirty)\r\n    {\r\n        this.textureDirty = false;\r\n        // set the vertex data\r\n        this.calculateVertices();\r\n    }\r\n\t\r\n\t//use different plugin for rendering\r\n    renderer.setObjectRenderer(renderer.plugins.picture);\r\n    renderer.plugins.picture.render(this);\r\n};\r\n\n},{}],4:[function(require,module,exports){\nvar myPlugin = {\r\n    PictureSprite: require('./PictureSprite'),\r\n    PictureRenderer: require('./PictureRenderer')\r\n};\r\n\r\n//dump everything into extras\r\n\r\nObject.assign(PIXI.extras, myPlugin);\r\n\r\nmodule.exports = myPlugin;\r\n\n},{\"./PictureRenderer\":1,\"./PictureSprite\":3}]},{},[4])\n\n","\r\n\r\n/**\r\n * @class\r\n * @extends PIXI.Shader\r\n * @memberof PIXI.extras\r\n * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\r\n */\r\nfunction PictureShader(gl)\r\n{\r\n    PIXI.Shader.call(this,\r\n        gl,\r\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\n\\nattribute vec2 aTextureCoord;\\n\\nattribute vec4 aColor;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n\\n{\\n\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n\\n}\\n\\n\",\r\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\n\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nuniform vec4 uTextureClamp;\\n\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n\\n{\\n\\n    vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\\n\\n   \\tvec4 sample = texture2D(uSampler, textureCoord);\\n\\n   \\tgl_FragColor = sample * uColor;\\n\\n}\\n\\n\"\r\n    );\r\n\t//do some stuff, like default values for shader\r\n\t//dont forget to bind it if you really are changing the uniforms\r\n\tthis.bind();\r\n\t//default tint\r\n\t//Its an example, actually PictureRenderer takes care of this stuff\r\n\tthis.uniforms.uColor = new Float32Array(1,1,1,1);\r\n}\r\n\r\nPictureShader.prototype = Object.create(PIXI.Shader.prototype);\r\nPictureShader.prototype.constructor = PictureShader;\r\nmodule.exports = PictureShader;\r\n","/**\r\n * A Sprite with reduced border artifacts\r\n *\r\n * @class\r\n * @extends PIXI.Sprite\r\n * @memberof PIXI.tilemap\r\n * @param texture {PIXI.Texture} the texture for this sprite\r\n */\r\nfunction PictureSprite(texture)\r\n{\r\n    PIXI.Sprite.call(this, texture);\r\n}\r\n\r\nPictureSprite.prototype = Object.create(PIXI.Sprite.prototype);\r\nPictureSprite.prototype.constructor = PictureSprite;\r\nmodule.exports = PictureSprite;\r\n\r\n/**\r\n * Renders the object using the WebGL renderer\r\n *\r\n * @param renderer {PIXI.WebGLRenderer}\r\n * @private\r\n */\r\nPictureSprite.prototype._renderWebGL = function (renderer)\r\n{\r\n\t//copy of PIXI.Sprite v4 behaviour\r\n    if(this.transform.updated || this.textureDirty)\r\n    {\r\n        this.textureDirty = false;\r\n        // set the vertex data\r\n        this.calculateVertices();\r\n    }\r\n\t\r\n\t//use different plugin for rendering\r\n    renderer.setObjectRenderer(renderer.plugins.picture);\r\n    renderer.plugins.picture.render(this);\r\n};\r\n","var myPlugin = {\r\n    PictureSprite: require('./PictureSprite'),\r\n    PictureRenderer: require('./PictureRenderer')\r\n};\r\n\r\n//dump everything into extras\r\n\r\nObject.assign(PIXI.extras, myPlugin);\r\n\r\nmodule.exports = myPlugin;\r\n"],"sourceRoot":"./"}